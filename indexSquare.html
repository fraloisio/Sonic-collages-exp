<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Floating Sound Bubbles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      position: relative;
    }
    body::before,
    body::after {
      display: none;
    }
    #p5-container {
      position: fixed;
      inset: 0;
    }
    .info-overlay {
      position: fixed;
      left: 1rem;
      top: 1rem;
      z-index: 10;
      font-size: 0.9rem;
      color: #aaa;
      background: rgba(0,0,0,0.6);
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="info-overlay">
    Floating sound bubbles Â· click a bubble to expand / play, click again to collapse / stop.
  </div>
  <div id="p5-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>

  <script>
    // ==============================
    // CONFIG
    // ==============================
    const CONFIG = {
      USE_LOCAL: true, // toggle between local CSV/paths and remote
      CSV_URL: "https://raw.githubusercontent.com/fraloisio/sonic-runs-assets/refs/heads/main/records.csv",
      LOCAL_CSV: "./records.csv",
      REFRESH_INTERVAL_MS: 30_000,
      BASE_RADIUS_MIN: 10,
      BASE_RADIUS_MAX: 45,
      EXPANDED_RADIUS: 225, // 450px diameter
      FADE_DURATION_MS: 700,
      LERP_SPEED: 0.1,
      DRIFT_SPEED: { min: 0.08, max: 0.18 },
      IMG_DRAW_SIZE: 350, // Fixed size for stable image rendering
      GLOW_ALPHA: 0.18,
      GLOW_RADIUS_MULTIPLIER: 2.5
    };

    const lerp = (a, b, t) => a + (b - a) * t;
    const randomRange = (min, max) => min + Math.random() * (max - min);

    // ==============================
    // STATE
    // ==============================
    const state = {
      bubbles: [],
      bubblesById: {},
      p5Instance: null,
      drag: { target: null, offsetX: 0, offsetY: 0, moved: false }
    };

    // ==============================
    // AUDIO MANAGER
    // ==============================
    class AudioManager {
      constructor(url) {
        this.audio = new Audio(url);
        this.audio.loop = true;
        this.audio.volume = 0;
        this.fadeInterval = null;
      }

      fade(targetVolume, duration, onComplete) {
        if (this.fadeInterval) clearInterval(this.fadeInterval);
        
        const startVolume = this.audio.volume;
        const startTime = performance.now();
        
        this.fadeInterval = setInterval(() => {
          const progress = Math.min(1, (performance.now() - startTime) / duration);
          this.audio.volume = lerp(startVolume, targetVolume, progress);
          
          if (progress >= 1) {
            clearInterval(this.fadeInterval);
            this.fadeInterval = null;
            if (onComplete) onComplete();
          }
        }, 40);
      }

      fadeIn(duration = CONFIG.FADE_DURATION_MS) {
        this.audio.play().catch(err => console.warn("Audio play error:", err));
        this.fade(1, duration);
      }

      fadeOut(duration = CONFIG.FADE_DURATION_MS) {
        this.fade(0, duration, () => this.audio.pause());
      }

      cleanup() {
        if (this.fadeInterval) clearInterval(this.fadeInterval);
        this.audio.pause();
      }
    }

    // ==============================
    // IMAGE COLOR SAMPLER
    // ==============================
    const ImageColorSampler = {
      async sampleColors(url) {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          
          img.onload = () => {
            try {
              const colors = this.extractColors(img);
              resolve(colors);
            } catch (e) {
              console.warn("Failed to sample colors:", e);
              resolve(this.getDefaultColors());
            }
          };
          
          img.onerror = () => {
            console.warn("Could not load image:", url);
            resolve(this.getDefaultColors());
          };
          
          img.src = url;
        });
      },

      extractColors(img) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const size = 16;
        
        canvas.width = size;
        canvas.height = size;
        ctx.drawImage(img, 0, 0, size, size);
        
        const data = ctx.getImageData(0, 0, size, size).data;
        let r = 0, g = 0, b = 0, count = 0;
        let maxBrightness = -1;
        let brightest = [200, 200, 200];
        
        for (let i = 0; i < data.length; i += 4) {
          r += data[i];
          g += data[i + 1];
          b += data[i + 2];
          count++;
          
          const brightness = data[i] + data[i + 1] + data[i + 2];
          if (brightness > maxBrightness) {
            maxBrightness = brightness;
            brightest = [data[i], data[i + 1], data[i + 2]];
          }
        }
        
        const avg = [r / count, g / count, b / count];
        const baseColor = avg.map(c => Math.min(255, Math.floor(c * 0.7 + 50)));
        const glowColor = brightest.map(c => Math.min(255, Math.floor(c * 1.2)));
        
        return { baseColor, glowColor };
      },

      getDefaultColors() {
        return {
          baseColor: [200, 200, 255],
          glowColor: [220, 220, 220]
        };
      }
    };

    // ==============================
    // BUBBLE CLASS
    // ==============================
    class Bubble {
      constructor(record) {
        this.id = record.id;
        this.title = record.title || "Untitled";
        this.description = record.description || "";
        this.imageUrl = record.imageUrl;
        this.audioUrl = record.audioUrl;
        
        this.image = null;
        this.audioManager = this.audioUrl ? new AudioManager(this.audioUrl) : null;
        
        this.baseColor = [200, 200, 255];
        this.glowColor = [220, 220, 220];
        
        this.initializePosition();
        this.initializeSize();

        this.expanded = false;
        this.imageAlpha = 0;
        this.clipProgress = 0;
        this.clipTarget = 0;
        
        if (this.imageUrl) {
          this.loadImageAndColors(this.imageUrl);
        }
      }

      initializePosition() {
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        const angle = Math.random() * Math.PI * 2;
        const speed = randomRange(CONFIG.DRIFT_SPEED.min, CONFIG.DRIFT_SPEED.max);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
      }

      initializeSize() {
        const baseRadius = randomRange(CONFIG.BASE_RADIUS_MIN, CONFIG.BASE_RADIUS_MAX);
        this.baseRadius = baseRadius;
        this.radius = baseRadius;
        this.targetRadius = baseRadius;
      }

      async loadImageAndColors(url) {
        const colors = await ImageColorSampler.sampleColors(url);
        this.baseColor = colors.baseColor;
        this.glowColor = colors.glowColor;
        
        if (state.p5Instance) {
          state.p5Instance.loadImage(
            url,
            img => { this.image = img; },
            err => console.warn("Could not load bubble image:", err)
          );
        }
      }

      setExpanded(expanded) {
        this.expanded = expanded;
        this.targetRadius = expanded ? CONFIG.EXPANDED_RADIUS : this.baseRadius;
        this.clipTarget = expanded ? 1 : 0;

        if (expanded) {
          this.bringToFront();
          this.audioManager?.fadeIn();
        } else {
          this.audioManager?.fadeOut();
        }
      }

      bringToFront() {
        const idx = state.bubbles.indexOf(this);
        if (idx >= 0) {
          state.bubbles.splice(idx, 1);
          state.bubbles.push(this);
        }
      }

      update() {
        this.updatePosition();
        this.updateAppearance();
      }

      updatePosition() {
        this.x += this.vx;
        this.y += this.vy;
        
        const margin = this.radius + 10;
        const { innerWidth: w, innerHeight: h } = window;
        
        if (this.x < margin) { this.x = margin; this.vx *= -1; }
        if (this.x > w - margin) { this.x = w - margin; this.vx *= -1; }
        if (this.y < margin) { this.y = margin; this.vy *= -1; }
        if (this.y > h - margin) { this.y = h - margin; this.vy *= -1; }
      }

      updateAppearance() {
        this.radius = lerp(this.radius, this.targetRadius, CONFIG.LERP_SPEED);
        // Snap to target when very close to prevent endless micro-adjustments
        if (Math.abs(this.radius - this.targetRadius) < 0.5) {
          this.radius = this.targetRadius;
        }
        this.imageAlpha = lerp(this.imageAlpha, this.expanded ? 255 : 0, CONFIG.LERP_SPEED);
        this.clipProgress = lerp(this.clipProgress, this.clipTarget, 0.12);
      }

      draw(p) {
        this.drawGlow(p);
        this.drawCircle(p);
        if (this.expanded) this.drawLabel(p);
      }

      drawGlow(p) {
        if (this.expanded) return;
        
        p.push();
        p.translate(this.x, this.y);
        p.blendMode(p.SCREEN);
        
        const ctx = p.drawingContext;
        const outerRadius = this.radius * CONFIG.GLOW_RADIUS_MULTIPLIER * 1.26;
        const gradient = ctx.createRadialGradient(0, 0, this.radius * 1.05, 0, 0, outerRadius);
        
        const [r, g, b] = this.glowColor;
        gradient.addColorStop(0, `rgba(${r},${g},${b},${CONFIG.GLOW_ALPHA * 0.8})`);
        gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        p.pop();
      }

      drawCircle(p) {
        p.push();
        p.translate(this.x, this.y);
        const ctx = p.drawingContext;
        ctx.save();
        const iw = this.image?.width || CONFIG.IMG_DRAW_SIZE;
        const ih = this.image?.height || CONFIG.IMG_DRAW_SIZE;
        const target = CONFIG.IMG_DRAW_SIZE * 1.1;
        const scale = Math.max(target / iw, target / ih);
        const drawW = iw * scale;
        const drawH = ih * scale;

        if (!this.expanded && this.clipProgress < 0.001) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.clip();
        } else {
          const startSize = this.radius * 2;
          const t = this.clipProgress;
          const w = lerp(startSize, drawW, t);
          const h = lerp(startSize, drawH, t);
          const corner = Math.max(0, Math.min(startSize / 2, lerp(this.radius, 0, t) * 0.9));
          const x = -w / 2;
          const y = -h / 2;
          ctx.beginPath();
          ctx.moveTo(x + corner, y);
          ctx.lineTo(x + w - corner, y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + corner);
          ctx.lineTo(x + w, y + h - corner);
          ctx.quadraticCurveTo(x + w, y + h, x + w - corner, y + h);
          ctx.lineTo(x + corner, y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - corner);
          ctx.lineTo(x, y + corner);
          ctx.quadraticCurveTo(x, y, x + corner, y);
          ctx.clip();
        }

        if (this.image) {
          p.blendMode(this.expanded ? p.BLEND : p.SCREEN);
          p.image(this.image, -drawW / 2, -drawH / 2, drawW, drawH);
        } else {
          p.blendMode(p.BLEND);
          const [r, g, b] = this.baseColor;
          const alpha = this.expanded ? 240 : 220;
          if (this.expanded) {
            p.rectMode(p.CENTER);
            p.rect(0, 0, CONFIG.IMG_DRAW_SIZE, CONFIG.IMG_DRAW_SIZE);
          } else {
            p.fill(r, g, b, alpha);
            p.circle(0, 0, this.radius * 2);
          }
        }
        
        ctx.restore();
        p.pop();
      }

      drawLabel(p) {
        p.fill(255);
        p.textAlign(p.CENTER, p.TOP);
        p.textSize(14);
        p.text(this.title, this.x, this.y + this.radius + 10);
      }

      hitTest(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        if (this.expanded) {
          const iw = this.image?.width || CONFIG.IMG_DRAW_SIZE;
          const ih = this.image?.height || CONFIG.IMG_DRAW_SIZE;
          const target = CONFIG.IMG_DRAW_SIZE * 1.1;
          const scale = Math.max(target / iw, target / ih);
          const w = iw * scale;
          const h = ih * scale;
          const startSize = this.radius * 2;
          const clipW = lerp(startSize, w, this.clipProgress);
          const clipH = lerp(startSize, h, this.clipProgress);
          return Math.abs(dx) <= clipW / 2 && Math.abs(dy) <= clipH / 2;
        }
        return dx * dx + dy * dy <= this.radius * this.radius;
      }

      updateData(record) {
        this.title = record.title || this.title;
        this.description = record.description || this.description;
        if (record.imageUrl && record.imageUrl !== this.imageUrl) {
          this.imageUrl = record.imageUrl;
          this.loadImageAndColors(record.imageUrl);
        }
        if (record.audioUrl && record.audioUrl !== this.audioUrl) {
          this.audioManager?.cleanup();
          this.audioUrl = record.audioUrl;
          this.audioManager = new AudioManager(record.audioUrl);
        }
        if (record.textUrl) {
          this.textUrl = record.textUrl;
        }
      }

      cleanup() {
        this.audioManager?.cleanup();
      }
    }

    // ==============================
    // CSV PARSER
    // ==============================
    const CSVParser = {
      parse(text) {
        const lines = this.splitLines(text);
        if (lines.length === 0) return [];
        
        const headers = this.parseRow(lines[0]).map(h => h.trim().toLowerCase());
        const rows = [];
        
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          const cols = this.parseRow(lines[i]);
          const row = {};
          headers.forEach((h, idx) => {
            row[h] = cols[idx] || "";
          });
          rows.push(row);
        }
        
        return rows;
      },

      splitLines(text) {
        const lines = [];
        let currentLine = "";
        let inQuotes = false;
        
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          
          if (ch === '"') {
            currentLine += ch;
            if (inQuotes && text[i + 1] === '"') {
              currentLine += text[++i];
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === "\n" && !inQuotes) {
            lines.push(currentLine.replace(/\r$/, ""));
            currentLine = "";
          } else {
            currentLine += ch;
          }
        }
        
        if (currentLine.trim()) {
          lines.push(currentLine.replace(/\r$/, ""));
        }
        
        return lines;
      },

      parseRow(line) {
        const result = [];
        let current = "";
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === ',' && !inQuotes) {
            result.push(current);
            current = "";
          } else {
            current += ch;
          }
        }
        
        result.push(current);
        return result;
      }
    };

    // ==============================
    // DATA MANAGER
    // ==============================
    const DataManager = {
      async fetchRecords() {
        try {
          const csvUrl = CONFIG.USE_LOCAL ? CONFIG.LOCAL_CSV : `${CONFIG.CSV_URL}?t=${Date.now()}`;
          const response = await fetch(csvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const text = await response.text();
          const rows = CSVParser.parse(text);
          const records = this.transformRows(rows);
          
          this.syncBubbles(records);
        } catch (error) {
          console.error("Error fetching CSV:", error);
        }
      },

      transformRows(rows) {
        const records = {};

        const localPath = (p, folder) => {
          if (!p) return "";
          const parts = p.split("/");
          const file = parts[parts.length - 1] || "";
          return folder && file ? `${folder}/${file}` : file;
        };

        rows.forEach(row => {
          const id = row.id?.trim();
          if (!id || !/^\d+/.test(id)) return;

          const title = row.title?.trim() || "";
          const imageLocal = row.image_local?.trim() || "";
          const imageRemote = row.image_url?.trim() || "";
          const audioLocal = row.audio_local?.trim() || "";
          const audioRemote = row.audio_url?.trim() || "";
          const textLocal = row.text_local?.trim() || "";
          const textRemote = row.text_url?.trim() || "";
          
          const useLocal = CONFIG.USE_LOCAL;
          const imageUrl = useLocal
            ? (localPath(imageLocal, "images") || imageRemote)
            : (imageRemote || localPath(imageLocal, "images"));
          const audioUrl = useLocal
            ? (localPath(audioLocal, "audio") || audioRemote)
            : (audioRemote || localPath(audioLocal, "audio"));
          const textUrl  = useLocal
            ? (localPath(textLocal, "texts")  || textRemote)
            : (textRemote || localPath(textLocal, "texts"));

          records[id] = {
            id,
            title,
            imageUrl,
            audioUrl,
            textUrl,
            description: [row.analysis, row.long_prompt].filter(p => p?.trim()).map(p => p.trim()).join("\n\n")
          };
        });
        
        return records;
      },

      syncBubbles(records) {
        // Remove deleted bubbles
        state.bubbles = state.bubbles.filter(bubble => {
          if (!records[bubble.id]) {
            bubble.cleanup();
            delete state.bubblesById[bubble.id];
            return false;
          }
          return true;
        });
        
        // Update or create bubbles
        for (const id in records) {
          const record = records[id];
          
          if (state.bubblesById[id]) {
            state.bubblesById[id].updateData(record);
          } else {
            const bubble = new Bubble(record);
            state.bubbles.push(bubble);
            state.bubblesById[id] = bubble;
          }
        }
        
        console.log(`Synced bubbles: ${state.bubbles.length}`);
      }
    };

    // ==============================
    // INTERACTION HANDLERS
    // ==============================
    const InteractionHandler = {
      onMousePressed(p) {
        state.drag = { target: null, offsetX: 0, offsetY: 0, moved: false, startX: p.mouseX, startY: p.mouseY };
        
        for (let i = state.bubbles.length - 1; i >= 0; i--) {
          const bubble = state.bubbles[i];
          if (bubble.hitTest(p.mouseX, p.mouseY)) {
            state.drag.target = bubble;
            state.drag.offsetX = p.mouseX - bubble.x;
            state.drag.offsetY = p.mouseY - bubble.y;
            break;
          }
        }
      },

      onMouseDragged(p) {
        if (state.drag.target) {
          state.drag.moved = true;
          state.drag.target.x = p.mouseX - state.drag.offsetX;
          state.drag.target.y = p.mouseY - state.drag.offsetY;
          state.drag.target.vx = 0;
          state.drag.target.vy = 0;
        }
      },

      onMouseReleased(p) {
        if (!state.drag.target) return;
        const dx = p.mouseX - state.drag.startX;
        const dy = p.mouseY - state.drag.startY;
        const movedDist = Math.hypot(dx, dy);
        
        if (!state.drag.moved || movedDist < 5) {
          state.drag.target.setExpanded(!state.drag.target.expanded);
        } else {
          const angle = Math.random() * Math.PI * 2;
          const speed = randomRange(0.05, 0.2);
          state.drag.target.vx = Math.cos(angle) * speed;
          state.drag.target.vy = Math.sin(angle) * speed;
        }
        
        state.drag = { target: null, offsetX: 0, offsetY: 0, moved: false };
      }
    };

    // ==============================
    // P5.JS SKETCH
    // ==============================
    new p5(p => {
      p.setup = () => {
        state.p5Instance = p;
        const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
        canvas.parent("p5-container");
        p.frameRate(60);
        
        DataManager.fetchRecords();
        setInterval(() => DataManager.fetchRecords(), CONFIG.REFRESH_INTERVAL_MS);
      };

      p.windowResized = () => {
        p.resizeCanvas(window.innerWidth, window.innerHeight);
      };

      p.draw = () => {
        p.background(0);
        state.bubbles.forEach(bubble => {
          bubble.update();
          bubble.draw(p);
        });
      };

      p.mousePressed = () => InteractionHandler.onMousePressed(p);
      p.mouseDragged = () => InteractionHandler.onMouseDragged(p);
      p.mouseReleased = () => InteractionHandler.onMouseReleased(p);
    });
  </script>
</body>
</html>
